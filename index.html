<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stochastic Sequencer with OSC Bridge</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    h1, h2 {
      color: #333;
    }
    .config-section {
      background-color: #e0e0e0;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    label {
      display: inline-block;
      width: 120px;
      margin-right: 10px;
    }
    input, select {
      padding: 5px;
      margin-right: 15px;
    }
    button {
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px 0;
    }
    button:hover {
      background-color: #45a049;
    }
    button.disconnect {
      background-color: #f44336;
    }
    #serverStatus, #oscStatus {
      color: #333;
      font-size: 14px;
      margin-top: 10px;
    }
    #synthControls {
      background-color: #e0e0e0;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    .osc-message {
      font-family: monospace;
      margin: 2px 0;
      padding: 2px 5px;
      background-color: #eee;
      border-radius: 3px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/osc-js@2.4.0/dist/osc.min.js"></script>
</head>
<body>
  <h1>Stochastic Sequencer with OSC Bridge</h1>
  
  <div class="config-section">
    <h2>Bridge Configuration</h2>
    <div>
      <label for="bridgeIp">Bridge IP:</label>
      <input type="text" id="bridgeIp" value="127.0.0.1">
      
      <label for="bridgePort">Bridge Port:</label>
      <input type="number" id="bridgePort" value="9000" min="1024" max="65535">
      
      <button id="updateBridgeConfig">Update Bridge</button>
    </div>
    <div id="serverStatus">Local WebSocket server: Stopped</div>
  </div>
  
  <div class="config-section">
    <h2>OSC Connection</h2>
    <div>
      <label for="oscType">Connection Type:</label>
      <select id="oscType">
        <option value="local">Local Bridge</option>
        <option value="ws">WebSocket</option>
        <option value="udp">UDP</option>
      </select>
      
      <label for="oscIp">Target IP:</label>
      <input type="text" id="oscIp" value="127.0.0.1">
      
      <label for="oscPort">Target Port:</label>
      <input type="number" id="oscPort" value="9000" min="1024" max="65535">
      
      <button id="connectOsc">Connect</button>
      <button id="disconnectOsc" class="disconnect" disabled>Disconnect</button>
    </div>
    <div id="oscStatus">OSC: Not connected</div>
  </div>
  
  <div id="synthControls">
    <h2>Synthesizer Controls</h2>
    <div>
      <label for="waveType">Waveform:</label>
      <select id="waveType">
        <option value="sine">Sine</option>
        <option value="square">Square</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="triangle">Triangle</option>
      </select>
      
      <label for="attackTime">Attack (ms):</label>
      <input type="range" id="attackTime" min="0" max="1000" value="50">
      <span id="attackValue">50</span>
      
      <label for="releaseTime">Release (ms):</label>
      <input type="range" id="releaseTime" min="0" max="1000" value="200">
      <span id="releaseValue">200</span>
    </div>
    <button id="testSynth">Test Synth</button>
  </div>
  
  <div class="config-section">
    <h2>OSC Test</h2>
    <button id="sendPlay">Send /play 440 0.5</button>
    <button id="sendStop">Send /stop</button>
    <p>For local bridge, connect to <strong>ws://<span id="displayBridgeIp">127.0.0.1</span>:<span id="displayBridgePort">9000</span></strong></p>
  </div>
  
  <div>
    <h2>OSC Messages</h2>
    <div id="oscMessages"></div>
  </div>
  
  <script>
    // Audio context and synth variables
    let audioContext;
    let gainNode;
    let oscillator;
    let activeNotes = {};
    
    // Initialize Web Audio
    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        gainNode.gain.value = 0;
        gainNode.connect(audioContext.destination);
        console.log("Web Audio initialized");
      } catch (e) {
        console.error("Web Audio initialization failed:", e);
        alert("Web Audio not supported in this browser");
      }
    }
    
    // Play a note
    function playNote(frequency, velocity = 1.0) {
      if (!audioContext) initAudio();
      
      const waveType = document.getElementById('waveType').value;
      const attackTime = document.getElementById('attackTime').value / 1000;
      const releaseTime = document.getElementById('releaseTime').value / 1000;
      
      if (!oscillator) {
        oscillator = audioContext.createOscillator();
        oscillator.type = waveType;
        oscillator.connect(gainNode);
        oscillator.start();
      } else {
        oscillator.type = waveType;
      }
      
      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
      gainNode.gain.cancelScheduledValues(audioContext.currentTime);
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(velocity, audioContext.currentTime + attackTime);
      gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + attackTime + releaseTime);
      
      const noteId = frequency.toFixed(2);
      activeNotes[noteId] = { oscillator, gainNode };
      
      setTimeout(() => {
        if (activeNotes[noteId]) {
          delete activeNotes[noteId];
        }
      }, (attackTime + releaseTime) * 1000 + 100);
    }
    
    // Stop all notes
    function stopAllNotes() {
      if (gainNode) {
        gainNode.gain.cancelScheduledValues(audioContext.currentTime);
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      }
      activeNotes = {};
    }
    
    // Test the synth
    document.getElementById('testSynth').addEventListener('click', () => {
      playNote(440, 0.5);
    });
    
    // Update slider values display
    document.getElementById('attackTime').addEventListener('input', function() {
      document.getElementById('attackValue').textContent = this.value;
    });
    
    document.getElementById('releaseTime').addEventListener('input', function() {
      document.getElementById('releaseValue').textContent = this.value;
    });
    
    // Bridge configuration
    let bridgeIp = "127.0.0.1";
    let bridgePort = 9000;
    
    // OSC message logging
    function logOscMessage(message) {
      const msgElement = document.createElement('div');
      msgElement.className = 'osc-message';
      msgElement.textContent = message;
      document.getElementById('oscMessages').appendChild(msgElement);
      document.getElementById('oscMessages').scrollTop = document.getElementById('oscMessages').scrollHeight;
    }
    
    // ==============================================
    // Embedded WebSocket-to-OSC Bridge
    // ==============================================
    let wsserver = null;
    let wsClients = new Set();
    let osc = null;
    let oscConnected = false;
    
    function updateBridgeDisplay() {
      document.getElementById('displayBridgeIp').textContent = bridgeIp;
      document.getElementById('displayBridgePort').textContent = bridgePort;
    }
    
    function startLocalServer() {
      try {
        wsserver = {
          port: bridgePort,
          close: () => {
            document.getElementById('serverStatus').textContent = `Local WebSocket server: Stopped`;
            wsClients.clear();
          }
        };
        
        document.getElementById('serverStatus').textContent = `Local WebSocket server: Running on ws://${bridgeIp}:${bridgePort}`;
        console.log(`WebSocket server running on ${bridgeIp}:${bridgePort}`);
        
        window.sendToLocalOscClient = function(address, ...args) {
          if (wsClients.size > 0) {
            console.log(`Forwarding OSC: ${address} ${args.join(' ')}`);
            document.getElementById('serverStatus').textContent = `Local WebSocket server: Forwarded ${address} ${args.join(' ')}`;
            
            if (address === '/play') {
              const freq = args[0] || 440;
              const vel = args[1] || 0.7;
              playNote(freq, vel);
            } else if (address === '/stop') {
              stopAllNotes();
            }
            
            logOscMessage(`Received: ${address} ${args.join(' ')}`);
          }
        };
        
      } catch (e) {
        console.error('Failed to start local server:', e);
        document.getElementById('serverStatus').textContent = 'Local WebSocket server: Failed to start - ' + e.message;
      }
    }
    
    function stopLocalServer() {
      if (wsserver) {
        wsserver.close();
        wsserver = null;
      }
    }
    
    // Handle bridge configuration updates
    document.getElementById('updateBridgeConfig').addEventListener('click', function() {
      const newIp = document.getElementById('bridgeIp').value.trim();
      const newPort = parseInt(document.getElementById('bridgePort').value);
      
      if (newIp && newPort >= 1024 && newPort <= 65535) {
        bridgeIp = newIp;
        bridgePort = newPort;
        updateBridgeDisplay();
        stopLocalServer();
        startLocalServer();
        console.log(`Bridge configuration updated to ${bridgeIp}:${bridgePort}`);
      } else {
        alert('Please enter valid IP and port (1024-65535)');
      }
    });
    
    // ==============================================
    // OSC Connection Handler
    // ==============================================
    function connectOsc() {
      const type = document.getElementById('oscType').value;
      const ip = document.getElementById('oscIp').value.trim();
      const port = parseInt(document.getElementById('oscPort').value);
      
      try {
        if (osc) {
          osc.close();
          osc = null;
        }
        
        if (type === 'local') {
          // Local bridge connection
          osc = {
            send: (msg) => {
              const address = msg.address;
              const args = msg.args.map(arg => arg.value);
              console.log(`Sending to local bridge: ${address} ${args.join(' ')}`);
              window.sendToLocalOscClient(address, ...args);
              logOscMessage(`Sent: ${address} ${args.join(' ')}`);
            },
            close: () => {
              oscConnected = false;
              updateOscStatus('Disconnected');
            }
          };
          
          oscConnected = true;
          updateOscStatus(`Connected to local bridge at ${ip}:${port}`);
          osc.send(new OSC.Message('/test', 1));
          logOscMessage('Sent /test 1 to local bridge');
          
        } else if (type === 'ws' || type === 'udp') {
          // WebSocket or UDP connection
          const config = {
            type: type === 'ws' ? OSC.WEBSOCKET : OSC.UDP,
            port: {
              local: { port: 0 }, // Random local port
              remote: { port: port, address: ip }
            }
          };
          
          osc = new OSC.WebSocketPort(config);
          
          osc.on('open', () => {
            oscConnected = true;
            updateOscStatus(`Connected to ${ip}:${port} via ${type.toUpperCase()}`);
          });
          
          osc.on('close', () => {
            oscConnected = false;
            updateOscStatus('Disconnected');
          });
          
          osc.on('error', (err) => {
            console.error('OSC error:', err);
            updateOscStatus(`Error: ${err.message}`);
          });
          
          osc.open();
        }
        
      } catch (e) {
        console.error('Connection error:', e);
        updateOscStatus(`Connection failed: ${e.message}`);
      }
    }
    
    function disconnectOsc() {
      if (osc) {
        try {
          if (osc.close) {
            osc.close();
          }
          osc = null;
          oscConnected = false;
          updateOscStatus('Disconnected');
        } catch (e) {
          console.error('Disconnection error:', e);
          updateOscStatus(`Disconnection failed: ${e.message}`);
        }
      }
    }
    
    function updateOscStatus(message) {
      document.getElementById('oscStatus').textContent = `OSC: ${message}`;
      document.getElementById('connectOsc').disabled = oscConnected;
      document.getElementById('disconnectOsc').disabled = !oscConnected;
    }
    
    // Set up event listeners
    document.getElementById('connectOsc').addEventListener('click', connectOsc);
    document.getElementById('disconnectOsc').addEventListener('click', disconnectOsc);
    
    document.getElementById('sendPlay').addEventListener('click', () => {
      if (osc && oscConnected) {
        try {
          const message = new OSC.Message('/play', 440, 0.5);
          if (typeof osc.send === 'function') {
            osc.send(message);
          } else if (osc.socket && osc.socket.send) {
            osc.socket.send(message);
          }
          logOscMessage('Sent /play 440 0.5');
        } catch (e) {
          console.error('Error sending message:', e);
          alert(`Error sending message: ${e.message}`);
        }
      } else {
        alert("Not connected to OSC. Please connect first.");
      }
    });
    
    document.getElementById('sendStop').addEventListener('click', () => {
      if (osc && oscConnected) {
        try {
          const message = new OSC.Message('/stop');
          if (typeof osc.send === 'function') {
            osc.send(message);
          } else if (osc.socket && osc.socket.send) {
            osc.socket.send(message);
          }
          logOscMessage('Sent /stop');
        } catch (e) {
          console.error('Error sending message:', e);
          alert(`Error sending message: ${e.message}`);
        }
      } else {
        alert("Not connected to OSC. Please connect first.");
      }
    });
    
    // Initialize
    initAudio();
    updateBridgeDisplay();
    startLocalServer();
  </script>
</body>
</html>