<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stochastic Sequencer with Wireless OSC</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
    }
    canvas {
      border: 1px solid #333;
      background-color: #fff;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    #status, #oscMessages {
      color: #333;
      font-size: 14px;
      max-width: 300px;
      text-align: center;
      white-space: pre-wrap;
    }
    #status {
      color: red;
    }
    input {
      margin: 5px;
      padding: 5px;
      font-size: 14px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/osc-js@2.4.0/dist/osc.min.js"></script>
</head>
<body>
  <h1>Stochastic Sequencer</h1>
  <p>Tilt front-to-back for scales, rotate for waveform, tilt gently for speed (20-200 BPM), tap/hold screen or use toggle for note duration. Enter IP/port and connect OSC to send to Pd wirelessly.</p>
  <label>OSC IP: <input id="oscIp" type="text" placeholder="192.168.1.100" value="192.168.1.100"></label>
  <label>Port: <input id="oscPort" type="number" placeholder="8000" value="8000"></label>
  <button id="connectOscBtn">Connect OSC</button>
  <button id="startBtn">Start</button>
  <button id="toggleDurationBtn">Toggle Duration (2.5s)</button>
  <div id="status"></div>
  <div id="oscMessages">OSC Messages:<br></div>
  <canvas id="visualizer" width="300" height="100"></canvas>
  <script>
    // Web Audio API setup
    let audioCtx;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      document.getElementById('status').textContent = 'Web Audio API not supported.';
      console.error('AudioContext creation failed:', e);
    }
    let isPlaying = false;

    // OSC setup
    let osc = null;
    let oscConnected = false;
    const oscMessagesDiv = document.getElementById('oscMessages');
    function logOscMessage(message) {
      const lines = oscMessagesDiv.innerText.split('\n');
      if (lines.length > 10) lines.shift();
      lines.push(message);
      oscMessagesDiv.innerText = lines.join('\n');
    }

    function connectOsc() {
      const ip = document.getElementById('oscIp').value;
      const port = parseInt(document.getElementById('oscPort').value);
      if (!ip || !port) {
        document.getElementById('status').textContent = 'Enter valid IP and port.';
        return;
      }
      try {
        if (osc) osc.close();
        osc = new OSC({ plugin: new OSC.WebsocketClientPlugin({ host: ip, port: port }) });
        osc.open();
        osc.on('open', () => {
          oscConnected = true;
          document.getElementById('status').textContent = `OSC connected to ${ip}:${port}`;
          console.log(`OSC connected to ${ip}:${port}`);
        });
        osc.on('error', (err) => {
          oscConnected = false;
          document.getElementById('status').textContent = 'OSC connection failed.';
          console.error('OSC error:', err);
        });
      } catch (e) {
        document.getElementById('status').textContent = 'OSC initialization failed.';
        console.error('OSC init failed:', e);
      }
    }

    document.getElementById('connectOscBtn').addEventListener('click', connectOsc);

    // Scale definitions
    const scales = {
      major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88],
      minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16],
      majorPent: [261.63, 293.66, 329.63, 392.00, 440.00],
      minorPent: [261.63, 311.13, 349.23, 392.00, 466.16]
    };
    let currentScale = scales.major;
    let markovChain = Array(currentScale.length).fill().map(() => 
      Array(currentScale.length).fill(1 / currentScale.length)
    );

    // Update Markov chain
    function updateMarkovChain() {
      for (let i = 0; i < currentScale.length; i++) {
        let row = markovChain[i];
        let total = 0;
        for (let j = 0; j < currentScale.length; j++) {
          row[j] = Math.random();
          total += row[j];
        }
        for (let j = 0; j < currentScale.length; j++) {
          row[j] /= total;
        }
      }
    }

    // Choose next note
    function chooseNextNote(currentNoteIdx) {
      const probs = markovChain[currentNoteIdx];
      let rand = Math.random();
      let sum = 0;
      for (let i = 0; i < probs.length; i++) {
        sum += probs[i];
        if (rand <= sum) return i;
      }
      return 0;
    }

    // Sound generation with OSC
    let currentWaveform = 'sine';
    let noteDuration = 1.0;
    function playNote(frequency, time) {
      if (!audioCtx) {
        document.getElementById('status').textContent = 'AudioContext unavailable.';
        return;
      }
      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.type = currentWaveform;
        oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + noteDuration);
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start(time);
        oscillator.stop(time + noteDuration);
        console.log(`Playing note: ${frequency}Hz, duration: ${noteDuration}s`);

        // Send OSC note
        if (osc && oscConnected) {
          const noteIdx = currentScale.indexOf(frequency);
          if (noteIdx !== -1) {
            const midiNote = 60 + noteIdx;
            const velocity = 100;
            osc.send(new OSC.Message('/note', midiNote, velocity, noteDuration));
            logOscMessage(`Sent /note ${midiNote} ${velocity} ${noteDuration}`);
            console.log(`OSC /note: ${midiNote}, ${velocity}, ${noteDuration}s`);
            setTimeout(() => {
              osc.send(new OSC.Message('/note', midiNote, 0, noteDuration));
              logOscMessage(`Sent /note ${midiNote} 0 ${noteDuration}`);
              console.log(`OSC /note: ${midiNote}, 0, ${noteDuration}s`);
            }, noteDuration * 1000);
          }
        }
      } catch (e) {
        console.error('Error playing note:', e);
        document.getElementById('status').textContent = 'Error playing sound.';
      }
    }

    // Send OSC CC
    function sendControlChanges(motionFactor, duration) {
      if (osc && oscConnected) {
        const ccTempo = motionFactor * 127;
        const ccDuration = (duration - 0.5) / 2 * 127;
        osc.send(new OSC.Message('/cc/20', ccTempo));
        osc.send(new OSC.Message('/cc/21', ccDuration));
        logOscMessage(`Sent /cc/20 ${ccTempo.toFixed(0)}`);
        logOscMessage(`Sent /cc/21 ${ccDuration.toFixed(0)}`);
        console.log(`OSC /cc/20: ${ccTempo.toFixed(0)}, /cc/21: ${ccDuration.toFixed(0)}`);
      }
    }

    // Visualizer
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    function drawVisualizer(noteIdx, motionFactor, scaleName, waveform, duration, isTouching, bpm) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = `hsl(${noteIdx * 360 / currentScale.length}, 70%, 50%)`;
      ctx.fillRect(0, 0, canvas.width * motionFactor, canvas.height);
      ctx.fillStyle = 'black';
      ctx.font = '12px Arial';
      const touchText = isTouching ? 'Touch: On' : 'Touch: Off';
      ctx.fillText(`${scaleName} | ${waveform} | Dur: ${duration.toFixed(2)}s | ${touchText} | BPM: ${bpm.toFixed(0)}`, 10, 20);
    }

    // Device motion
    let motionFactor = 0;
    function handleMotion(event) {
      if (!event.accelerationIncludingGravity) {
        document.getElementById('status').textContent = 'Motion data unavailable.';
        return;
      }
      const { x, y, z } = event.accelerationIncludingGravity;
      const magnitude = Math.sqrt(x * x + y * y + z * z);
      motionFactor = (magnitude - 9.8) / 5;
      motionFactor = Math.min(Math.max(motionFactor, 0), 1);
      const bpm = 20 + motionFactor * (200 - 20);
      sendControlChanges(motionFactor, noteDuration);
      console.log(`Motion: ${motionFactor.toFixed(2)}, BPM: ${bpm.toFixed(0)}`);
    }

    // Device orientation
    let currentScaleName = 'Major';
    function handleOrientation(event) {
      if (!event.beta || !event.alpha) {
        document.getElementById('status').textContent = 'Orientation data unavailable.';
        return;
      }
      const beta = event.beta;
      if (beta < -45) {
        currentScale = scales.minorPent;
        currentScaleName = 'Minor Pent';
      } else if (beta < 0) {
        currentScale = scales.minor;
        currentScaleName = 'Minor';
      } else if (beta < 45) {
        currentScale = scales.major;
        currentScaleName = 'Major';
      } else {
        currentScale = scales.majorPent;
        currentScaleName = 'Major Pent';
      }
      markovChain = Array(currentScale.length).fill().map(() => 
        Array(currentScale.length).fill(1 / currentScale.length)
      );
      const alpha = event.alpha;
      if (alpha < 90) {
        currentWaveform = 'sine';
      } else if (alpha < 180) {
        currentWaveform = 'square';
      } else if (alpha < 270) {
        currentWaveform = 'triangle';
      } else {
        currentWaveform = 'sawtooth';
      }
    }

    // Touch handling
    let isTouching = false;
    function setupTouchControls() {
      document.body.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isTouching = true;
        noteDuration = 0.5;
        sendControlChanges(motionFactor, noteDuration);
        console.log('Touch started, duration: 0.5s');
      });
      document.body.addEventListener('touchend', (e) => {
        e.preventDefault();
        isTouching = false;
        noteDuration = 2.5;
        sendControlChanges(motionFactor, noteDuration);
        console.log('Touch ended, duration: 2.5s');
      });
      document.body.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        isTouching = false;
        noteDuration = 2.5;
        sendControlChanges(motionFactor, noteDuration);
        console.log('Touch cancelled, duration: 2.5s');
      });
    }

    // Toggle duration
    const toggleDurationBtn = document.getElementById('toggleDurationBtn');
    toggleDurationBtn.addEventListener('click', () => {
      if (noteDuration === 0.5) {
        noteDuration = 2.5;
        toggleDurationBtn.textContent = 'Toggle Duration (2.5s)';
        console.log('Toggle button: duration set to 2.5s');
      } else {
        noteDuration = 0.5;
        toggleDurationBtn.textContent = 'Toggle Duration (0.5s)';
        console.log('Toggle button: duration set to 0.5s');
      }
      sendControlChanges(motionFactor, noteDuration);
    });

    // Calculate delay
    function getNoteDelay(motionFactor) {
      const minBPM = 20;
      const maxBPM = 200;
      const minDelay = 60000 / maxBPM;
      const maxDelay = 60000 / minBPM;
      return maxDelay - (maxDelay - minDelay) * motionFactor;
    }

    // Sequencer loop
    let currentNoteIdx = 0;
    function sequencerLoop() {
      if (!isPlaying) return;
      updateMarkovChain();
      currentNoteIdx = chooseNextNote(currentNoteIdx % currentScale.length);
      playNote(currentScale[currentNoteIdx], audioCtx.currentTime);
      const bpm = 20 + motionFactor * (200 - 20);
      drawVisualizer(currentNoteIdx, motionFactor, currentScaleName, currentWaveform, noteDuration, isTouching, bpm);
      const delay = getNoteDelay(motionFactor);
      setTimeout(sequencerLoop, delay);
    }

    // Start button
    document.getElementById('startBtn').addEventListener('click', async () => {
      if (!audioCtx) {
        document.getElementById('status').textContent = 'Audio not available.';
        return;
      }
      if (audioCtx.state === 'suspended') {
        try {
          await audioCtx.resume();
          console.log('AudioContext resumed:', audioCtx.state);
        } catch (e) {
          console.error('Failed to resume AudioContext:', e);
          document.getElementById('status').textContent = 'Failed to start audio.';
          return;
        }
      }
      if (!isPlaying) {
        isPlaying = true;
        setupTouchControls();
        sequencerLoop();
        document.getElementById('startBtn').textContent = 'Stop';
      } else {
        isPlaying = false;
        document.getElementById('status').textContent = '';
        document.getElementById('startBtn').textContent = 'Start';
      }
    });

    // Permissions
    if (typeof DeviceMotionEvent.requestPermission === 'function' || 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      document.getElementById('startBtn').addEventListener('click', async () => {
        const motionPromise = typeof DeviceMotionEvent.requestPermission === 'function' 
          ? DeviceMotionEvent.requestPermission() 
          : Promise.resolve('granted');
        const orientationPromise = typeof DeviceOrientationEvent.requestPermission === 'function' 
          ? DeviceOrientationEvent.requestPermission() 
          : Promise.resolve('granted');
        try {
          const [motionState, orientationState] = await Promise.all([motionPromise, orientationPromise]);
          if (motionState === 'granted') {
            window.addEventListener('devicemotion', handleMotion);
          } else {
            document.getElementById('status').textContent += ' Motion permission denied.';
          }
          if (orientationState === 'granted') {
            window.addEventListener('deviceorientation', handleOrientation);
          } else {
            document.getElementById('status').textContent += ' Orientation permission denied.';
          }
        } catch (e) {
          console.error('Permission error:', e);
          document.getElementById('status').textContent = 'Failed to access sensors.';
        }
      });
    } else {
      window.addEventListener('devicemotion', handleMotion);
      window.addEventListener('deviceorientation', handleOrientation);
    }
  </script>
</body>
</html>