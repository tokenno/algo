<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stochastic Sequencer with MIDI</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
    }
    canvas {
      border: 1px solid #333;
      background-color: #fff;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    #status {
      color: red;
      font-size: 14px;
      max-width: 300px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Stochastic Sequencer</h1>
  <p>Tilt front-to-back for scales, rotate for waveform, tilt gently for speed (20-200 BPM), tap/hold screen or use toggle for note duration. Sends MIDI to DAW. Click "Start" to begin.</p>
  <button id="startBtn">Start</button>
  <button id="toggleDurationBtn">Toggle Duration (2.5s)</button>
  <div id="status"></div>
  <canvas id="visualizer" width="300" height="100"></canvas>
  <script>
    // Web Audio API setup
    let audioCtx;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      document.getElementById('status').textContent = 'Web Audio API not supported.';
      console.error('AudioContext creation failed:', e);
    }
    let isPlaying = false;

    // Web MIDI setup
    let midiAccess = null;
    let midiOutput = null;
    navigator.requestMIDIAccess().then(
      (access) => {
        midiAccess = access;
        midiOutput = Array.from(midiAccess.outputs.values())[0];
        if (!midiOutput) {
          document.getElementById('status').textContent += ' No MIDI output devices found.';
          console.error('No MIDI outputs available.');
        } else {
          console.log('MIDI output:', midiOutput.name);
        }
      },
      (err) => {
        document.getElementById('status').textContent += ' Web MIDI access denied.';
        console.error('Failed to access MIDI:', err);
      }
    );

    // Scale definitions
    const scales = {
      major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88],
      minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16],
      majorPent: [261.63, 293.66, 329.63, 392.00, 440.00],
      minorPent: [261.63, 311.13, 349.23, 392.00, 466.16]
    };
    let currentScale = scales.major;
    let markovChain = Array(currentScale.length).fill().map(() => 
      Array(currentScale.length).fill(1 / currentScale.length)
    );

    // Update Markov chain
    function updateMarkovChain() {
      for (let i = 0; i < currentScale.length; i++) {
        let row = markovChain[i];
        let total = 0;
        for (let j = 0; j < currentScale.length; j++) {
          row[j] = Math.random();
          total += row[j];
        }
        for (let j = 0; j < currentScale.length; j++) {
          row[j] /= total;
        }
      }
    }

    // Choose next note
    function chooseNextNote(currentNoteIdx) {
      const probs = markovChain[currentNoteIdx];
      let rand = Math.random();
      let sum = 0;
      for (let i = 0; i < probs.length; i++) {
        sum += probs[i];
        if (rand <= sum) return i;
      }
      return 0;
    }

    // Sound generation with MIDI
    let currentWaveform = 'sine';
    let noteDuration = 1.0;
    function playNote(frequency, time) {
      if (!audioCtx) {
        document.getElementById('status').textContent = 'AudioContext unavailable.';
        return;
      }
      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.type = currentWaveform;
        oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + noteDuration);
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start(time);
        oscillator.stop(time + noteDuration);
        console.log(`Playing note: ${frequency}Hz, duration: ${noteDuration}s`);

        // Send MIDI note
        if (midiOutput) {
          const noteIdx = currentScale.indexOf(frequency);
          if (noteIdx !== -1) {
            const midiNote = 60 + noteIdx; // C4 + scale offset
            const velocity = 100;
            midiOutput.send([0x90, midiNote, velocity]); // Note on
            setTimeout(() => {
              midiOutput.send([0x80, midiNote, 0]); // Note off
            }, noteDuration * 1000);
            console.log(`MIDI Note: ${midiNote}, Duration: ${noteDuration}s`);
          }
        }
      } catch (e) {
        console.error('Error playing note:', e);
        document.getElementById('status').textContent = 'Error playing sound.';
      }
    }

    // Send MIDI CC for motionFactor and noteDuration
    function sendControlChanges(motionFactor, duration) {
      if (midiOutput) {
        const ccTempo = Math.round(motionFactor * 127); // CC 20 for tempo
        const ccDuration = Math.round((duration - 0.5) / 2 * 127); // CC 21 for duration (0.5-2.5s)
        midiOutput.send([0xB0, 20, ccTempo]);
        midiOutput.send([0xB0, 21, ccDuration]);
        console.log(`MIDI CC 20: ${ccTempo}, CC 21: ${ccDuration}`);
      }
    }

    // Visualizer
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    function drawVisualizer(noteIdx, motionFactor, scaleName, waveform, duration, isTouching, bpm) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = `hsl(${noteIdx * 360 / currentScale.length}, 70%, 50%)`;
      ctx.fillRect(0, 0, canvas.width * motionFactor, canvas.height);
      ctx.fillStyle = 'black';
      ctx.font = '12px Arial';
      const touchText = isTouching ? 'Touch: On' : 'Touch: Off';
      ctx.fillText(`${scaleName} | ${waveform} | Dur: ${duration.toFixed(2)}s | ${touchText} | BPM: ${bpm.toFixed(0)}`, 10, 20);
    }

    // Device motion (speed, 20 BPM at rest)
    let motionFactor = 0;
    function handleMotion(event) {
      if (!event.accelerationIncludingGravity) {
        document.getElementById('status').textContent = 'Motion data unavailable.';
        return;
      }
      const { x, y, z } = event.accelerationIncludingGravity;
      const magnitude = Math.sqrt(x * x + y * y + z * z);
      motionFactor = (magnitude - 9.8) / 5;
      motionFactor = Math.min(Math.max(motionFactor, 0), 1);
      const bpm = 20 + motionFactor * (200 - 20);
      sendControlChanges(motionFactor, noteDuration);
      console.log(`Motion: ${motionFactor.toFixed(2)}, BPM: ${bpm.toFixed(0)}`);
    }

    // Device orientation (scale, waveform)
    let currentScaleName = 'Major';
    function handleOrientation(event) {
      if (!event.beta || !event.alpha) {
        document.getElementById('status').textContent = 'Orientation data unavailable.';
        return;
      }
      const beta = event.beta;
      if (beta < -45) {
        currentScale = scales.minorPent;
        currentScaleName = 'Minor Pent';
      } else if (beta < 0) {
        currentScale = scales.minor;
        currentScaleName = 'Minor';
      } else if (beta < 45) {
        currentScale = scales.major;
        currentScaleName = 'Major';
      } else {
        currentScale = scales.majorPent;
        currentScaleName = 'Major Pent';
      }
      markovChain = Array(currentScale.length).fill().map(() => 
        Array(currentScale.length).fill(1 / currentScale.length)
      );
      const alpha = event.alpha;
      if (alpha < 90) {
        currentWaveform = 'sine';
      } else if (alpha < 180) {
        currentWaveform = 'square';
      } else if (alpha < 270) {
        currentWaveform = 'triangle';
      } else {
        currentWaveform = 'sawtooth';
      }
    }

    // Touch handling
    let isTouching = false;
    function setupTouchControls() {
      document.body.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isTouching = true;
        noteDuration = 0.5;
        sendControlChanges(motionFactor, noteDuration);
        console.log('Touch started, duration: 0.5s');
      });
      document.body.addEventListener('touchend', (e) => {
        e.preventDefault();
        isTouching = false;
        noteDuration = 2.5;
        sendControlChanges(motionFactor, noteDuration);
        console.log('Touch ended, duration: 2.5s');
      });
      document.body.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        isTouching = false;
        noteDuration = 2.5;
        sendControlChanges(motionFactor, noteDuration);
        console.log('Touch cancelled, duration: 2.5s');
      });
    }

    // Toggle duration
    const toggleDurationBtn = document.getElementById('toggleDurationBtn');
    toggleDurationBtn.addEventListener('click', () => {
      if (noteDuration === 0.5) {
        noteDuration = 2.5;
        toggleDurationBtn.textContent = 'Toggle Duration (2.5s)';
        console.log('Toggle button: duration set to 2.5s');
      } else {
        noteDuration = 0.5;
        toggleDurationBtn.textContent = 'Toggle Duration (0.5s)';
        console.log('Toggle button: duration set to 0.5s');
      }
      sendControlChanges(motionFactor, noteDuration);
    });

    // Calculate delay
    function getNoteDelay(motionFactor) {
      const minBPM = 20;
      const maxBPM = 200;
      const minDelay = 60000 / maxBPM;
      const maxDelay = 60000 / minBPM;
      return maxDelay - (maxDelay - minDelay) * motionFactor;
    }

    // Sequencer loop
    let currentNoteIdx = 0;
    function sequencerLoop() {
      if (!isPlaying) return;
      updateMarkovChain();
      currentNoteIdx = chooseNextNote(currentNoteIdx % currentScale.length);
      playNote(currentScale[currentNoteIdx], audioCtx.currentTime);
      const bpm = 20 + motionFactor * (200 - 20);
      drawVisualizer(currentNoteIdx, motionFactor, currentScaleName, currentWaveform, noteDuration, isTouching, bpm);
      const delay = getNoteDelay(motionFactor);
      setTimeout(sequencerLoop, delay);
    }

    // Start button
    document.getElementById('startBtn').addEventListener('click', async () => {
      if (!audioCtx) {
        document.getElementById('status').textContent = 'Audio not available.';
        return;
      }
      if (audioCtx.state === 'suspended') {
        try {
          await audioCtx.resume();
          console.log('AudioContext resumed:', audioCtx.state);
        } catch (e) {
          console.error('Failed to resume AudioContext:', e);
          document.getElementById('status').textContent = 'Failed to start audio.';
          return;
        }
      }
      if (!isPlaying) {
        isPlaying = true;
        setupTouchControls();
        sequencerLoop();
        document.getElementById('startBtn').textContent = 'Stop';
      } else {
        isPlaying = false;
        document.getElementById('status').textContent = '';
        document.getElementById('startBtn').textContent = 'Start';
      }
    });

    // Permissions
    if (typeof DeviceMotionEvent.requestPermission === 'function' || 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      document.getElementById('startBtn').addEventListener('click', async () => {
        const motionPromise = typeof DeviceMotionEvent.requestPermission === 'function' 
          ? DeviceMotionEvent.requestPermission() 
          : Promise.resolve('granted');
        const orientationPromise = typeof DeviceOrientationEvent.requestPermission === 'function' 
          ? DeviceOrientationEvent.requestPermission() 
          : Promise.resolve('granted');
        try {
          const [motionState, orientationState] = await Promise.all([motionPromise, orientationPromise]);
          if (motionState === 'granted') {
            window.addEventListener('devicemotion', handleMotion);
          } else {
            document.getElementById('status').textContent += ' Motion permission denied.';
          }
          if (orientationState === 'granted') {
            window.addEventListener('deviceorientation', handleOrientation);
          } else {
            document.getElementById('status').textContent += ' Orientation permission denied.';
          }
        } catch (e) {
          console.error('Permission error:', e);
          document.getElementById('status').textContent = 'Failed to access sensors.';
        }
      });
    } else {
      window.addEventListener('devicemotion', handleMotion);
      window.addEventListener('deviceorientation', handleOrientation);
    }
  </script>
</body>
</html>